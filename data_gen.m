function [AA,A,B,yy,yy_mis,y,y_mis,y_nonPhase,A_p,y_p,y_p_mis,x] = data_gen(m,n,sparsity,packetSize,fc,jiterConst,addNoiPow)
%%%%%%%%%%%%%%%%%%%%%%%%% Generate data for algorithm comparison
%%%%%%%%%%%%%%%%%%%%%%%%% Inputs: 
% m - measurement number
% n - antenna number
% sparsity - sparse level of the channel in angle domain
% packetSize - number of measurements in a packet for PC-MP and PC-CPR
% fc - carrier frequency
% jiterConst - jiter constant related to the power of phase noise
% addNoiPow - additive noise power
%%%%%%%%%%%%%%%%%%%%%%%%% Outputs: 
% AA - measurement matrix for PC-CPR & PC-MP sampled from Fourier matrix
% A - measurement matrix for OMP & SparseLift sampled from Fourier matrix
% B - structured matrix for SparseLift
% yy - measurements generated by AA. The phase noise is a constant for each packet
% yy_mis - measurements generated by AA. The phase noise varies in each packet
% y - measurements generated by A. The phase noise is a constant for each packet
% y_mis - measurements generated by A. The phase noise varies in each packet
% y_nonPhase - measurements generated by A. For phase noise free case
% A_p - measurement matrix corresponding to each packet generated by AA
% y_p - measurements corresponding to each packet. The phase noise is a constant for each packet
% y_p_mis - measurements corresponding to each packet. The phase noise varies in each packet
% x - sparse channel vector

%channel model
steerVector = ones(n,1);
DoA = randn(sparsity,1) * 2 * pi;
pathGain = rand(1,1) + 1j * rand(1,1);
channelSpatial = zeros(n,1);
for k = 1:1:sparsity
    MT = 0:1:n-1;
    steerVector = exp(MT'*1j*pi*DoA(k)); %geometric sequence
    channelSpatial = channelSpatial + steerVector * pathGain;
end
clear k;
%sparse representation
z = dftmtx(n) * channelSpatial;
indices=retin(abs(z),sparsity);
x = zeros(n,1);
x(indices) = z(indices);
x = x/norm(x);
%x = z/norm(z);

% % Construct ideal x
pack_num = m/packetSize;

% measurement matrix
row = (0:(n-1))'*(0:(n-1));
Fouri = exp(-2*pi*1j*row/n); %fourier matrix
slc = randperm(n); %random sampling
slc = slc(1:m);
AA = Fouri(slc,:);

% Wiener phase noise
ang = randn(1,1);
phase = zeros(1,m);
Ts = 0;
for k = 1:1:m
    Ts = Ts + 128; %128ns per measurement
    pow = 4*(pi^2)*(fc^2)*jiterConst.*Ts.*1e-9; %ns
    if(mod(k-1,packetSize)==0)
        ang = randn(1,1);
        Ts = 0;
    end
    phase(k) = exp(1j * ang);
    ang = ang + pow.*randn(1,1); %accumulation
end
clear k;

phase_s = zeros(pack_num,1);
for k = 1:1:pack_num
    phase_s(k) = phase(packetSize*k);
end
clear ang;
clear k;
        
%B
B = zeros(m,m/packetSize);                                                                                                                         
e = ones(packetSize,1);
row  = 1;
for col = 1:1:m/packetSize
    B(row:row+packetSize-1,col) = e;
    row = row + packetSize;
end
clear row col e;
add_noise = (addNoiPow .*randn(m,1)+addNoiPow .*randn(m,1)*1i);
yy = diag(B*phase_s) * AA * x + add_noise;
yy_mis = diag(phase) * AA * x + add_noise;
y_nonPhase = AA * x + add_noise;

% Rewrite model
A_p = zeros(packetSize,n,pack_num);
y_p = zeros(packetSize,pack_num);
y_p_mis = zeros(packetSize,pack_num);
A = zeros(m,n);
y = zeros(m,1);
y_mis = zeros(m,1);


idx = 1;
for p = 1:1:pack_num
    slc = randperm(n); %random sampling
    slc = slc(1:m);
    A_A = Fouri(slc,:);
    A_p(:,:,p) = A_A(idx:idx+packetSize-1,:);
    y_p(:,p) = phase_s(p) * A_p(:,:,p) * x + add_noise(idx:idx+packetSize-1);
    y_p_mis(:,p) = diag(phase((p-1)*packetSize+1:p*packetSize)) * A_p(:,:,p) * x + add_noise(idx:idx+packetSize-1);
    %y_p(:,p) = y(idx:idx+pack_size-1);
    A(idx:idx+packetSize-1,:) = A_p(:,:,p);
    y(idx:idx+packetSize-1) = y_p(:,p);
    y_mis(idx:idx+packetSize-1) = y_p_mis(:,p);
    idx = idx+packetSize;
end
    clear idx p